# Orb 'https://raw.githubusercontent.com/CircleCI-Labs/test-cpm/eb81bcba6c11d8018d7fe7e6cfb7bfc7ce31f5b8/.circleci/team-config.yml' resolved to 'https://raw.githubusercontent.com/CircleCI-Labs/test-cpm/eb81bcba6c11d8018d7fe7e6cfb7bfc7ce31f5b8/.circleci/team-config.yml'
version: 2
jobs:
  Build Application:
    machine:
      image: ubuntu-2204:current
      docker_layer_caching: true
    steps:
    - checkout
    - run:
        command: |
          #!/usr/bin/env bash

          # Import "utils.sh".
          eval "$SCRIPT_UTILS"
          expand_env_vars_with_prefix "PARAM_"

          if [[ $EUID == 0 ]]; then export SUDO=""; else export SUDO="sudo"; fi

          # grab Docker version
          if [[ "$PARAM_VERSION" == "latest" ]]; then
            # extract latest version from GitHub releases API
            declare -i INDEX=0

            while :
            do
              INDEX_VERSION=$(curl --silent --show-error --location --fail --retry 3 \
                https://api.github.com/repos/docker/cli/tags | \
                jq --argjson index "$INDEX" '.[$index].name')

              # filter out betas & release candidates
              # shellcheck disable=SC2143 # Doesn't apply to this case.
              if [[ $(echo "$INDEX_VERSION" | grep -v beta | grep -v rc) ]]; then

                # can't use substring expression < 0 on macOS
                DOCKER_VERSION="${INDEX_VERSION:1:$((${#INDEX_VERSION} - 1 - 1))}"

                echo "Latest stable version of Docker is $DOCKER_VERSION"
                break
              else
                INDEX=$((INDEX+1))
              fi
            done
          else
            DOCKER_VERSION="$PARAM_VERSION"
            echo "Selected version of Docker is $DOCKER_VERSION"
          fi

          # check if Docker needs to be installed
          DOCKER_VERSION_NUMBER="${DOCKER_VERSION:1}"

          if command -v docker >> /dev/null 2>&1; then
            if docker --version | grep "$DOCKER_VERSION_NUMBER" >> /dev/null 2>&1; then
              echo "Docker $DOCKER_VERSION is already installed"
              exit 0
            else
              echo "A different version of Docker is installed ($(docker --version)); removing it"
              $SUDO rm -f "$(command -v docker)"
            fi
          fi

          # get binary download URL for specified version
          if uname -a | grep Darwin >> /dev/null 2>&1; then
            PLATFORM=mac
          else
            PLATFORM=linux
          fi

          SYS_ARCH=$(uname -m)

          if [ "$SYS_ARCH" == "arm64" ]; then
            SYS_ARCH="aarch64"
          fi

          DOCKER_BINARY_URL="https://download.docker.com/$PLATFORM/static/stable/$SYS_ARCH/docker-$DOCKER_VERSION_NUMBER.tgz"

          # download binary tarball
          DOWNLOAD_DIR="$(mktemp -d)"
          DOWNLOAD_FILE="${DOWNLOAD_DIR}/docker.tgz"
          curl --output "$DOWNLOAD_FILE" \
            --silent --show-error --location --fail --retry 3 \
            "$DOCKER_BINARY_URL"

          tar xf "$DOWNLOAD_FILE" -C "$DOWNLOAD_DIR" && rm -f "$DOWNLOAD_FILE"

          # install Docker binaries
          BINARIES=$(ls "${DOWNLOAD_DIR}/docker")
          $SUDO mv "$DOWNLOAD_DIR"/docker/* "$PARAM_INSTALL_DIR"
          $SUDO rm -rf "$DOWNLOAD_DIR"

          for binary in $BINARIES
          do
            $SUDO chmod +x "$PARAM_INSTALL_DIR/$binary"
          done

          # verify version
          echo "$(docker --version) has been installed to $(command -v docker)"
        environment:
          PARAM_INSTALL_DIR: /usr/local/bin
          PARAM_VERSION: latest
          SCRIPT_UTILS: |
            #!/usr/bin/env bash

            # Public: Expand the value from environment variables with given prefix.
            #
            # Takes a prefix as an argument and expands the value of the environment variables
            # starting with the prefix. The expansion is done by using the eval command.
            #
            # $1 - Prefix used to filter the envinronment variables.
            #
            # Examples
            #
            #   expand_env_vars_with_prefix "ORB_PARAM_"
            #   expand_env_vars_with_prefix "PARAM_"
            #
            # Returns 1 if no argument is provided or no environment variables were found with prefix.
            # Returns 0 if the expansion was successful.
            expand_env_vars_with_prefix() {
              if [ "$#" -eq 0 ]; then
                >&2 printf '%s\n' "Please provide a prefix to filter the envinronment variables."
                return 1
              fi

              # Fetch parameters from the environment variables.
              local prefix="$1"
              local env_vars
              env_vars="$(printenv | grep "^$prefix")"

              if [ -z "$env_vars" ]; then
                >&2 printf '%s\n' "No environment variables found with the prefix: \"$prefix\"."
                return 1
              fi

              while IFS= read -ra line; do
                # Split the line into key and value.
                local var_value="${line#*=}"
                local var_name="${line%="$var_value"}"

                # Expand the value.
                local expanded_value
                expanded_value="$(eval echo "$var_value")"

                # The -v option assignes the output to a variable rather than printing it.
                printf -v "$var_name" "%s" "$expanded_value"
              done <<< "$env_vars"
              return 0
            }
        name: Install Docker CLI
    - run:
        command: |
          #!/usr/bin/env bash

          # Import "utils.sh".
          eval "$SCRIPT_UTILS"
          expand_env_vars_with_prefix "PARAM_"

          echo "${!PARAM_DOCKER_PASSWORD}" | docker login -u "${!PARAM_DOCKER_USERNAME}" --password-stdin "$PARAM_REGISTRY"
        environment:
          PARAM_DOCKER_PASSWORD: DOCKER_PASSWORD
          PARAM_DOCKER_USERNAME: DOCKER_LOGIN
          PARAM_REGISTRY: docker.io
          SCRIPT_UTILS: |
            #!/usr/bin/env bash

            # Public: Expand the value from environment variables with given prefix.
            #
            # Takes a prefix as an argument and expands the value of the environment variables
            # starting with the prefix. The expansion is done by using the eval command.
            #
            # $1 - Prefix used to filter the envinronment variables.
            #
            # Examples
            #
            #   expand_env_vars_with_prefix "ORB_PARAM_"
            #   expand_env_vars_with_prefix "PARAM_"
            #
            # Returns 1 if no argument is provided or no environment variables were found with prefix.
            # Returns 0 if the expansion was successful.
            expand_env_vars_with_prefix() {
              if [ "$#" -eq 0 ]; then
                >&2 printf '%s\n' "Please provide a prefix to filter the envinronment variables."
                return 1
              fi

              # Fetch parameters from the environment variables.
              local prefix="$1"
              local env_vars
              env_vars="$(printenv | grep "^$prefix")"

              if [ -z "$env_vars" ]; then
                >&2 printf '%s\n' "No environment variables found with the prefix: \"$prefix\"."
                return 1
              fi

              while IFS= read -ra line; do
                # Split the line into key and value.
                local var_value="${line#*=}"
                local var_name="${line%="$var_value"}"

                # Expand the value.
                local expanded_value
                expanded_value="$(eval echo "$var_value")"

                # The -v option assignes the output to a variable rather than printing it.
                printf -v "$var_name" "%s" "$expanded_value"
              done <<< "$env_vars"
              return 0
            }
        name: Docker login
    - run:
        command: |
          #!/usr/bin/env bash

          # Import "utils.sh".
          eval "$SCRIPT_UTILS"
          expand_env_vars_with_prefix "PARAM_"
          DOCKER_TAGS_ARG=""

          parse_tags_to_docker_arg() {
            # Set comma as the new delimiter for the scope of this function.
            local IFS=","

            # Split tags into an array based on IFS delimiter.
            read -ra tags <<< "$PARAM_TAG"

            local docker_arg

            for tag in "${tags[@]}"; do
              if [ -z "$docker_arg" ]; then
                docker_arg="--tag=\"$PARAM_REGISTRY/$PARAM_IMAGE:$tag\""
              else
                docker_arg="$docker_arg --tag=\"$PARAM_REGISTRY/$PARAM_IMAGE:$tag\""
              fi
            done

            # Set IFS to null to stop "," from breaking bash substitution
            local IFS=
            DOCKER_TAGS_ARG="$(eval echo $docker_arg)"
          }

          if ! parse_tags_to_docker_arg; then
            echo "Unable to parse provided tags."
            echo "Check your \"tag\" parameter or refer to the docs and try again: https://circleci.com/developer/orbs/orb/circleci/docker."
            exit 1
          fi

          build_args=(
            "--file=$PARAM_DOCKERFILE_PATH/$PARAM_DOCKERFILE_NAME"
          )

          eval 'for t in '$DOCKER_TAGS_ARG'; do build_args+=("$t"); done'

          if [ -n "$EXTRA_BUILD_ARGS" ]; then
            eval 'for p in '$EXTRA_BUILD_ARGS'; do build_args+=("$p"); done'
          fi

          if [ -n "$PARAM_CACHE_FROM" ]; then
            cache_from=$(eval echo $PARAM_CACHE_FROM)

            build_args+=("--cache-from=$cache_from")
          fi

          if [ -n "$PARAM_CACHE_TO" ]; then
            cache_to="$(eval echo $PARAM_CACHE_TO)"

            docker buildx create --name cache --use
            docker buildx use cache
            build_args+=("--cache-to=$cache_to" --load)
          fi

          # The context must be the last argument.
          build_args+=("$PARAM_DOCKER_CONTEXT")

          old_ifs="$IFS"
          IFS=' '

          set -x
          docker buildx build "${build_args[@]}"
          set +x

          IFS="$old_ifs"
        environment:
          EXTRA_BUILD_ARGS: --progress=plain
          PARAM_CACHE_FROM: starter-template:latest
          PARAM_CACHE_TO: ''
          PARAM_DOCKER_CONTEXT: .
          PARAM_DOCKERFILE_NAME: Dockerfile
          PARAM_DOCKERFILE_PATH: .
          PARAM_IMAGE: starter-template
          PARAM_REGISTRY: docker.io
          PARAM_TAG: latest
          PARAM_USE_BUILDKIT: false
          SCRIPT_UTILS: |
            #!/usr/bin/env bash

            # Public: Expand the value from environment variables with given prefix.
            #
            # Takes a prefix as an argument and expands the value of the environment variables
            # starting with the prefix. The expansion is done by using the eval command.
            #
            # $1 - Prefix used to filter the envinronment variables.
            #
            # Examples
            #
            #   expand_env_vars_with_prefix "ORB_PARAM_"
            #   expand_env_vars_with_prefix "PARAM_"
            #
            # Returns 1 if no argument is provided or no environment variables were found with prefix.
            # Returns 0 if the expansion was successful.
            expand_env_vars_with_prefix() {
              if [ "$#" -eq 0 ]; then
                >&2 printf '%s\n' "Please provide a prefix to filter the envinronment variables."
                return 1
              fi

              # Fetch parameters from the environment variables.
              local prefix="$1"
              local env_vars
              env_vars="$(printenv | grep "^$prefix")"

              if [ -z "$env_vars" ]; then
                >&2 printf '%s\n' "No environment variables found with the prefix: \"$prefix\"."
                return 1
              fi

              while IFS= read -ra line; do
                # Split the line into key and value.
                local var_value="${line#*=}"
                local var_name="${line%="$var_value"}"

                # Expand the value.
                local expanded_value
                expanded_value="$(eval echo "$var_value")"

                # The -v option assignes the output to a variable rather than printing it.
                printf -v "$var_name" "%s" "$expanded_value"
              done <<< "$env_vars"
              return 0
            }
        name: Docker build
        no_output_timeout: 10m
    - run:
        name: Save Docker image
        command: |
          docker save -o starter-template.tar starter-template:latest
    - persist_to_workspace:
        root: .
        paths:
        - starter-template.tar
    - store_artifacts:
        path: starter-template.tar
        destination: docker-image
  Deploy Application:
    docker:
    - image: cimg/base:stable
    steps:
    - run:
        command: echo "Deploying the application..."
  Test Application:
    docker:
    - image: cimg/python:3.13.4
    steps:
    - checkout
    - run:
        command: |
          # shellcheck disable=SC2016
          echo 'if [ "${PARAM_PKG_MNGR}" = "auto" ]; then
            if [ -f "requirements.txt" ]; then
                if [ -f "${PARAM_SETUP_FILE_PATH:-setup.py}" ]; then
                    export DETECT_PKG_MNGR="pip-dist"
                else
                    export DETECT_PKG_MNGR="pip"
                fi
                elif [ -f "Pipfile" ]; then
                export DETECT_PKG_MNGR="pipenv"
                export PYTHON_ENV_TOOL="pipenv"
                elif [ -f "uv.lock" ]; then
                export DETECT_PKG_MNGR="uv"
                export PYTHON_ENV_TOOL="uv"
                elif [ -f "pyproject.toml" ]; then
                export DETECT_PKG_MNGR="poetry"
                export PYTHON_ENV_TOOL="poetry"
            fi
            echo "INFO: Detected Package Manager ${DETECT_PKG_MNGR}"
          fi' > /tmp/detect-env.sh
          chmod +x /tmp/detect-env.sh
          echo 'export AUTO_DETECT_ENV_SCRIPT="/tmp/detect-env.sh"' >> "$BASH_ENV"
        name: Export automatic environment detection script
    - run:
        command: |
          if [ ! "${BASH_ENV_PYTHON_ALIASED}" ]; then
              echo 'if [ ! $(command -v python) ]; then
            shopt -s expand_aliases
            alias python=python3
            alias pip=pip3
          fi

          BASH_ENV_PYTHON_ALIASED=true' >> "$BASH_ENV"
          fi
        name: Alias Python
    - run:
        command: |
          # shellcheck source=detect-env.sh
          source "$AUTO_DETECT_ENV_SCRIPT"

          CACHE_DIR=".cci_pycache"
          LOCKFILE_PATH="${CACHE_DIR}/lockfile"

          mkdir -p "${CACHE_DIR}"

          if [ ! -f "${LOCKFILE_PATH}" ]; then
              case ${DETECT_PKG_MNGR:-${PARAM_PKG_MNGR}} in
                  pip | pip-dist)
                      LOCK_FILE="${PARAM_DEPENDENCY_FILE:-requirements.txt}"
                  ;;
                  pipenv)
                      LOCK_FILE="Pipfile.lock"
                  ;;
                  poetry)
                      LOCK_FILE="poetry.lock"
                  ;;
                  uv)
                      LOCK_FILE="uv.lock"
                  ;;
              esac
              
              if [ -z "${LOCK_FILE}" ]; then
                  echo "WARNING: Could not determine lockfile path for ${DETECT_PKG_MNGR:-PARAM_PKG_MNGR}"
              else
                  FULL_LOCK_FILE=$(readlink -f "${LOCK_FILE}")

                  if [ -f "${LOCK_FILE}" ]; then
                      echo "INFO: Copying ${FULL_LOCK_FILE} to ${LOCKFILE_PATH}"
                      cp "${FULL_LOCK_FILE}" "${LOCKFILE_PATH}"
                  else
                      echo "WARNING: Could not find lockfile at ${LOCK_FILE}"
                  fi
              fi
          fi
        environment:
          PARAM_DEPENDENCY_FILE: requirements.txt
          PARAM_PKG_MNGR: pip
          PARAM_PYPI_CACHE: true
          PARAM_VENV_CACHE: true
          PARAM_VENV_PATH: ''
        name: Link lockfile
        working_directory: .
    - run:
        command: python --version | cut -d ' ' -f2 > .temp-python-version && cat .temp-python-version
        name: Save python version
    - restore_cache:
        keys:
        - v1-cci_pycache-{{ .Branch }}-{{ checksum ".temp-python-version" }}-{{ checksum "./.cci_pycache/lockfile" }}
        - v1-cci_pycache-{{ .Branch }}-{{ checksum ".temp-python-version" }}-
    - run:
        command: |
          recurse() {
              if [ ! -d "$1" ] || [ ! -e "$2" ]; then
                  mv -u "$1" "$2" || exit
                  return
              fi
              for entry in "$1/"* "$1/."[!.]* "$1/.."?*; do
                  if [ -e "$entry" ]; then
                      recurse "$entry" "$2/${entry##"$1/"}"
                  fi
              done
          }

          restore_paths() {
              if [ -d "${1}" ] && [ -n "$(ls -A "${1}" 2>/dev/null)" ]; then
                  for file in "${1}"/*; do
                      decoded=$(basename "${file}" | base64 -d)
                      parent_dir=$(dirname "${decoded}")
                      
                      # make sure the parent directories exist
                      if [ ! -d "${parent_dir}" ]; then
                          mkdir -p "${parent_dir}"
                      fi
                      
                      echo "INFO: Restoring ${file} to ${decoded}"

                      recurse "${file}" "${decoded}"
                  done
              fi
          }

          CACHE_DIR=".cci_pycache"

          if [ "${PARAM_VENV_CACHE}" = "1" ]; then
              restore_paths "${CACHE_DIR}/venv"
          fi

          if [ "${PARAM_PYPI_CACHE}" = "1" ]; then
              restore_paths "${CACHE_DIR}/pypi"
          fi
        environment:
          PARAM_PYPI_CACHE: true
          PARAM_VENV_CACHE: true
        name: Move restored cache
        working_directory: .
    - run:
        command: |
          pip install -r requirements.txt 
        name: Install dependencies with pip using project requirements.txt
        no_output_timeout: 10m
        working_directory: .
    - run:
        command: |
          # shellcheck source=detect-env.sh
          source "$AUTO_DETECT_ENV_SCRIPT"

          case ${DETECT_PKG_MNGR:-${PARAM_PKG_MNGR}} in
              pip | pip-dist)
                  LOCK_FILE="${PARAM_DEPENDENCY_FILE:-requirements.txt}"
                  CACHE_PATHS='[ "/home/circleci/.cache/pip", "/home/circleci/.pyenv/versions", "/home/circleci/.local/lib" ]'
              ;;
              pipenv) # TODO: use PIPENV_PIPFILE
                  LOCK_FILE="Pipfile.lock"
                  PIPENV_VENV_PATH="${WORKON_HOME:-/home/circleci/.local/share/virtualenvs}"
                  
                  if [ -z "${PIPENV_VENV_IN_PROJECT}" ]; then
                      VENV_PATHS="[ \"${PIPENV_VENV_PATH}\" ]"
                  else
                      VENV_PATHS="[ \"${CIRCLE_WORKING_DIRECTORY}/.venvs\" ]"
                  fi
                  
                  CACHE_PATHS='[ "/home/circleci/.cache/pip", "/home/circleci/.cache/pipenv" ]'
              ;;
              poetry)
                  LOCK_FILE="poetry.lock"
                  VENV_PATHS='[ "/home/circleci/.cache/pypoetry/virtualenvs" ]'
                  CACHE_PATHS='[ "/home/circleci/.cache/pip" ]'
              ;;
              uv)
                  LOCK_FILE="uv.lock"
                  VENV_PATHS="[ \"${CIRCLE_WORKING_DIRECTORY}/.venv\" ]"
                  CACHE_PATHS='[ "/home/circleci/.cache/uv" ]'
              ;;
          esac

          if [ -n "${PARAM_VENV_PATH}" ]; then
              VENV_PATHS="${PARAM_VENV_PATH}"
          fi

          CACHE_DIR=".cci_pycache"
          mkdir -p "${CACHE_DIR}"

          link_paths() {
              if [ -d "${1}" ]; then
                  echo "INFO: Cache directory already exists. Skipping..."
                  return
              fi
              
              mkdir "${1}"
              
              for encoded in $(echo "${2}" | jq -r '.[] | @base64'); do
                  decoded=$(echo "${encoded}" | base64 -d)
                  
                  if [ -e "${decoded}" ]; then
                      echo "INFO: Copying ${decoded} to ${1}/${encoded}"
                      cp -a "${decoded}" "${1}/${encoded}"
                  else
                      echo "INFO: Could not find ${decoded}. Skipping..."
                  fi
              done
          }

          if [ "${PARAM_VENV_CACHE}" = "1" ] && [ -n "${VENV_PATHS}" ]; then
              link_paths "${CACHE_DIR}/venv" "${VENV_PATHS}"
          fi

          if [ "${PARAM_PYPI_CACHE}" = "1" ]; then
              link_paths "${CACHE_DIR}/pypi" "${CACHE_PATHS}"
          fi

          LOCKFILE_PATH="${CACHE_DIR}/lockfile"

          if [ -e "${LOCKFILE_PATH}" ]; then
              rm -f "${LOCKFILE_PATH}"
          fi

          if [ -e "${LOCK_FILE}" ]; then
              FULL_LOCK_FILE=$(readlink -f "${LOCK_FILE}")
              
              echo "INFO: Copying ${FULL_LOCK_FILE} to ${LOCKFILE_PATH}"
              cp "${FULL_LOCK_FILE}" "${LOCKFILE_PATH}"
          fi
        environment:
          PARAM_DEPENDENCY_FILE: requirements.txt
          PARAM_PKG_MNGR: pip
          PARAM_PYPI_CACHE: true
          PARAM_VENV_CACHE: true
          PARAM_VENV_PATH: ''
        name: Copy to cache directory
        working_directory: .
    - save_cache:
        key: v1-cci_pycache-{{ .Branch }}-{{ checksum ".temp-python-version" }}-{{ checksum "./.cci_pycache/lockfile" }}
        paths:
        - ./.cci_pycache
    - restore_cache:
        keys:
        - v1-pydeps-{{ checksum "requirements.txt" }}-{{ checksum "requirements-dev.txt" }}
    - run:
        name: Install dependencies
        command: |
          python -m venv venv
          . venv/bin/activate
          pip install --upgrade pip setuptools
          pip install -r requirements.txt
          pip install -r requirements-dev.txt
          pip install -e .
    - save_cache:
        key: v1-pydeps-{{ checksum "requirements.txt" }}-{{ checksum "requirements-dev.txt" }}
        paths:
        - ./venv
    - run:
        name: Run pytest with timing and junit output
        command: |
          . venv/bin/activate
          mkdir -p test-results
          pytest --junitxml=test-results/junit.xml --durations=0
    - store_test_results:
        path: test-results
    - store_artifacts:
        path: test-results
        destination: test-results
workflows:
  version: 2
  main:
    jobs:
    - Build Application:
        context: share-docker-publishing
    - Test Application:
        requires:
        - Build Application
        upstream:
          Build Application:
          - success
    - Deploy Application:
        requires:
        - Test Application
        upstream:
          Test Application:
          - success